name: Deploy to AWS K3s

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: docker.io
  API_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-api
  WORKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-worker
  AWS_REGION: us-east-1

jobs:
  # ===== 1. Quality Gate =====
  quality:
    name: ðŸ§ª Quality Gate
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Run Tests - API
      working-directory: ./app/api-service
      run: go test -v ./...
    
    - name: Run Tests - Worker
      working-directory: ./app/worker-service
      run: go test -v ./...

  # ===== 2. Build & Push Docker Images =====
  build:
    name: ðŸ³ Build & Push
    runs-on: ubuntu-latest
    needs: quality
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build and push API
      uses: docker/build-push-action@v5
      with:
        context: ./app/api-service
        push: true
        tags: |
          ${{ env.API_IMAGE }}:${{ github.sha }}
          ${{ env.API_IMAGE }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build and push Worker
      uses: docker/build-push-action@v5
      with:
        context: ./app/worker-service
        push: true
        tags: |
          ${{ env.WORKER_IMAGE }}:${{ github.sha }}
          ${{ env.WORKER_IMAGE }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # ===== 3. Deploy to AWS K3s Cluster =====
  deploy-aws:
    name:  Deploy to AWS K3s
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get K3s Master Instance ID
      id: get-instance
      run: |
        # Get K3s master instance ID from terraform outputs or tags
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=*k3s-master*" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "Found K3s master: $INSTANCE_ID"
    
    - name: Deploy to K3s via SSM
      env:
        INSTANCE_ID: ${{ steps.get-instance.outputs.instance-id }}
      run: |
        echo "ðŸš€ Deploying to K3s cluster..."
        
        # Create deployment script
        cat > deploy-commands.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸ“¦ Starting deployment to K3s..."
        
        # Update to latest images
        echo "ðŸ”„ Updating API deployment..."
        kubectl set image deployment/api \
          api=${{ env.API_IMAGE }}:${{ github.sha }} \
          -n production-platform
        
        echo "ðŸ”„ Updating Worker deployment..."
        kubectl set image deployment/worker \
          worker=${{ env.WORKER_IMAGE }}:${{ github.sha }} \
          -n production-platform
        
        # Wait for rollouts
        echo "â³ Waiting for API rollout..."
        kubectl rollout status deployment/api \
          -n production-platform \
          --timeout=180s
        
        echo "â³ Waiting for Worker rollout..."
        kubectl rollout status deployment/worker \
          -n production-platform \
          --timeout=180s
        
        # Verify deployment
        echo "âœ… Deployment complete! Pod status:"
        kubectl get pods -n production-platform
        
        echo ""
        echo "ðŸ“Š Deployment details:"
        kubectl describe deployment/api -n production-platform | grep -A 3 "Image:"
        kubectl describe deployment/worker -n production-platform | grep -A 3 "Image:"
        EOF
        
        # Execute deployment via SSM
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[$(cat deploy-commands.sh | jq -Rs .)]" \
          --comment "GitHub Actions K3s Deployment" \
          --query 'Command.CommandId' \
          --output text)
        
        echo "Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        echo "â³ Waiting for deployment to complete..."
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID"
        
        # Get command output
        echo "ðŸ“‹ Deployment output:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
    
    - name: Health Check
      env:
        INSTANCE_ID: ${{ steps.get-instance.outputs.instance-id }}
      run: |
        echo "ðŸ¥ Running health checks..."
        
        # Health check script
        cat > health-check.sh << 'EOF'
        #!/bin/bash
        
        echo "Testing API health endpoint..."
        kubectl run test-health --rm -i --restart=Never \
          --image=curlimages/curl:latest \
          --namespace=production-platform \
          -- curl -f -s http://api:8080/health || echo "API health check failed"
        
        echo ""
        echo "Current pod status:"
        kubectl get pods -n production-platform -o wide
        
        echo ""
        echo "Recent events:"
        kubectl get events -n production-platform --sort-by='.lastTimestamp' | tail -10
        EOF
        
        # Execute health check
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[$(cat health-check.sh | jq -Rs .)]" \
          --query 'Command.CommandId' \
          --output text)
        
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID"
        
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
    
    - name: Deployment Summary
      if: success()
      run: |
        echo "## âœ… Deployment Successful!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Deployed Images:**" >> $GITHUB_STEP_SUMMARY
        echo "- API: \`${{ env.API_IMAGE }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- Worker: \`${{ env.WORKER_IMAGE }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Cluster:** AWS K3s (\`${{ steps.get-instance.outputs.instance-id }}\`)" >> $GITHUB_STEP_SUMMARY
        echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
    
    - name: Rollback on Failure
      if: failure()
      env:
        INSTANCE_ID: ${{ steps.get-instance.outputs.instance-id }}
      run: |
        echo "âŒ Deployment failed! Rolling back..."
        
        cat > rollback.sh << 'EOF'
        kubectl rollout undo deployment/api -n production-platform
        kubectl rollout undo deployment/worker -n production-platform
        echo "Rollback initiated"
        EOF
        
        aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[$(cat rollback.sh | jq -Rs .)]"
        
        echo "## âŒ Deployment Failed - Rollback Initiated" >> $GITHUB_STEP_SUMMARY
