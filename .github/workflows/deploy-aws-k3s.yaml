name: Deploy to AWS K3s (Imperative)

on:
  #push:
  #  branches: [ main ]
   # paths:
    #  - 'app/**'
     # - '.github/workflows/deploy-aws-k3s.yaml'
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  REGISTRY: docker.io
  API_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-api
  WORKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-worker

jobs:
  # ===== 1. Quality Gate =====
  quality:
    name: üß™ Quality Gate
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Run Tests - API
      working-directory: ./app/api-service
      run: go test -v ./...
    
    - name: Run Tests - Worker
      working-directory: ./app/worker-service
      run: go test -v ./...

  # ===== 2. Build & Push Docker Images =====
  build:
    name: üê≥ Build & Push
    runs-on: ubuntu-latest
    needs: quality
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build and push API
      uses: docker/build-push-action@v5
      with:
        context: ./app/api-service
        push: true
        tags: |
          ${{ env.API_IMAGE }}:${{ github.sha }}
          ${{ env.API_IMAGE }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build and push Worker
      uses: docker/build-push-action@v5
      with:
        context: ./app/worker-service
        push: true
        tags: |
          ${{ env.WORKER_IMAGE }}:${{ github.sha }}
          ${{ env.WORKER_IMAGE }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # ===== 3. Deploy to AWS K3s Cluster =====
  deploy-aws:
    name:  Deploy to AWS K3s
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get K3s Master Instance ID
      id: get-instance
      run: |
        # Get K3s master instance ID from terraform outputs or tags
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=*k3s-master*" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "Found K3s master: $INSTANCE_ID"
    
    - name: Upload K8s Manifests to S3
      run: |
        echo "üì¶ Uploading manifests to S3..."
        BUCKET_NAME="k3s-deploy-$(date +%s)"
        aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}
        
        # Upload all manifests
        tar czf manifests.tar.gz k8s/
        aws s3 cp manifests.tar.gz s3://$BUCKET_NAME/manifests.tar.gz
        
        echo "bucket-name=$BUCKET_NAME" >> $GITHUB_OUTPUT
      id: upload-manifests
    
    - name: Deploy to K3s via SSM
      env:
        INSTANCE_ID: ${{ steps.get-instance.outputs.instance-id }}
        BUCKET_NAME: ${{ steps.upload-manifests.outputs.bucket-name }}
      run: |
        echo "üöÄ Deploying to K3s cluster..."
        
        # Execute deployment via SSM - using proper JSON format
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters '{
            "commands": [
              "set -e",
              "cd /tmp",
              "echo \"üì• Downloading manifests from S3...\"",
              "aws s3 cp s3://'"$BUCKET_NAME"'/manifests.tar.gz .",
              "tar xzf manifests.tar.gz",
              "cd k8s/base",
              "echo \"üì¶ Starting deployment to K3s...\"",
              "echo \"üîß Creating namespace and configmap...\"",
              "kubectl apply -f namespace.yaml",
              "kubectl apply -f configmap.yaml",
              "echo \"üî¥ Deploying Redis...\"",
              "kubectl apply -f redis/",
              "echo \"‚è≥ Waiting for Redis to be ready...\"",
              "kubectl wait --for=condition=ready pod -l app=redis -n production-platform --timeout=120s || true",
              "echo \"üîÑ Updating image tags in manifests...\"",
              "sed -i \"s|image: .*/production-platform-api:.*|image: '"${{ env.API_IMAGE }}:${{ github.sha }}"'|g\" api/deployment.yaml",
              "sed -i \"s|image: .*/production-platform-worker:.*|image: '"${{ env.WORKER_IMAGE }}:${{ github.sha }}"'|g\" worker/deployment.yaml",
              "echo \"üöÄ Deploying API service...\"",
              "kubectl apply -f api/",
              "echo \"‚öôÔ∏è Deploying Worker service...\"",
              "kubectl apply -f worker/",
              "echo \"‚è≥ Waiting for API rollout...\"",
              "kubectl rollout status deployment/api -n production-platform --timeout=180s",
              "echo \"‚è≥ Waiting for Worker rollout...\"",
              "kubectl rollout status deployment/worker -n production-platform --timeout=180s",
              "echo \"‚úÖ Deployment complete! Pod status:\"",
              "kubectl get pods -n production-platform -o wide",
              "echo \"\"",
              "echo \"üìä Deployment details:\"",
              "kubectl get all -n production-platform",
              "echo \"\"",
              "echo \"üßπ Cleanup...\"",
              "cd /tmp && rm -rf k8s manifests.tar.gz"
            ]
          }' \
          --comment "GitHub Actions K3s Deployment" \
          --query 'Command.CommandId' \
          --output text)
        
        echo "Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        echo "‚è≥ Waiting for deployment to complete..."
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" || {
          echo "‚ùå Deployment command failed. Fetching error details..."
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardErrorContent' \
            --output text
          exit 1
        }
        
        # Get command output
        echo "üìã Deployment output:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
    
    - name: Cleanup S3 Bucket
      if: always()
      run: |
        if [ -n "${{ steps.upload-manifests.outputs.bucket-name }}" ]; then
          aws s3 rb s3://${{ steps.upload-manifests.outputs.bucket-name }} --force || true
        fi
    
    - name: Health Check
      env:
        INSTANCE_ID: ${{ steps.get-instance.outputs.instance-id }}
      run: |
        echo "üè• Running health checks..."
        
        # Execute health check
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters '{
            "commands": [
              "echo \"Current pod status:\"",
              "kubectl get pods -n production-platform -o wide",
              "echo \"\"",
              "echo \"Recent events:\"",
              "kubectl get events -n production-platform --sort-by=.lastTimestamp | tail -10"
            ]
          }' \
          --query 'Command.CommandId' \
          --output text)
        
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID"
        
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
    
    - name: Deployment Summary
      if: success()
      run: |
        echo "## ‚úÖ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Deployed Images:**" >> $GITHUB_STEP_SUMMARY
        echo "- API: \`${{ env.API_IMAGE }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- Worker: \`${{ env.WORKER_IMAGE }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Cluster:** AWS K3s (\`${{ steps.get-instance.outputs.instance-id }}\`)" >> $GITHUB_STEP_SUMMARY
        echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
    
    - name: Rollback on Failure
      if: failure()
      env:
        INSTANCE_ID: ${{ steps.get-instance.outputs.instance-id }}
      run: |
        echo "‚ùå Deployment failed! Rolling back..."
        
        aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters '{
            "commands": [
              "kubectl rollout undo deployment/api -n production-platform || true",
              "kubectl rollout undo deployment/worker -n production-platform || true",
              "echo \"Rollback initiated\""
            ]
          }'