name: Production Platform CI/CD

on:
  #push:
  #  branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: docker.io
  API_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-api
  WORKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-worker

jobs:
  # ===== 1. Quality Gate =====
  quality:
    name: üß™ Quality Gate
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Run Tests
      run: |
        cd app/api-service && go test -v ./...
        cd ../worker-service && go test -v ./...
    
      

  # ===== 2. Build & Push =====
  build:
    name: üê≥ Build & Push
    runs-on: ubuntu-latest
    needs: quality
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build and push API
      uses: docker/build-push-action@v5
      with:
        context: ./app/api-service
        push: true
        tags: |
          ${{ env.API_IMAGE }}:${{ github.sha }}
          ${{ env.API_IMAGE }}:latest
    
    - name: Build and push Worker
      uses: docker/build-push-action@v5
      with:
        context: ./app/worker-service
        push: true
        tags: |
          ${{ env.WORKER_IMAGE }}:${{ github.sha }}
          ${{ env.WORKER_IMAGE }}:latest

  # ===== 3. Deploy to Kind (Using the Helm/kind action for setting up the Cluster  ) =====
  deploy-test:
    name: üöÄ Deploy & Test
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Kind Cluster
      uses: helm/kind-action@v1
      with:
        cluster_name: production-platform
        # Optional: Configure a local registry for built images
        # registry: true
        # registry_name: local-registry
        # registry_port: 5000
    
    - name: Deploy to Kind
      run: |
        # Create namespace
        
        echo "üì¶ Deploying Kubernetes manifests in correct order..."
        
        # 1. First: Deploy namespace 
        if [ -f "k8s/base/namespace.yaml" ]; then
          echo "1. Applying namespace..."
          kubectl apply -f k8s/base/namespace.yaml
        fi
        
        # 2. Deploy ConfigMaps and Secrets
        echo "2. Applying configuration..."
        for config_file in k8s/base/configmap.yaml k8s/base/secret.yaml; do
          if [ -f "$config_file" ]; then
            kubectl apply -f "$config_file" -n production-platform
          fi
        done
        
        # 3. Deploy Redis first (StatefulSet, needs to be ready before API/Worker)
        echo "3. Deploying Redis (StatefulSet)..."
        if [ -d "k8s/base/redis" ]; then
          # Apply service before statefulset
          if [ -f "k8s/base/redis/service.yaml" ]; then
            kubectl apply -f k8s/base/redis/service.yaml -n production-platform
          fi
          if [ -f "k8s/base/redis/statefulset.yaml" ]; then
            kubectl apply -f k8s/base/redis/statefulset.yaml -n production-platform
          fi
        fi
        
        # 4. Wait for Redis to be ready
        echo "‚è≥ Waiting for Redis to be ready..."
        sleep 20  # Give Redis time to start
        
        # 5. Deploy Services (before deployments that reference them)
        echo "4. Deploying Services..."
        for dir in api worker; do
          if [ -d "k8s/base/$dir" ] && [ -f "k8s/base/$dir/service.yaml" ]; then
            kubectl apply -f k8s/base/$dir/service.yaml -n production-platform
          fi
        done
        
        # 6. Deploy Deployments (API and Worker)
        echo "5. Deploying Deployments..."
        for dir in api worker; do
          if [ -d "k8s/base/$dir" ] && [ -f "k8s/base/$dir/deployment.yaml" ]; then
            kubectl apply -f k8s/base/$dir/deployment.yaml -n production-platform
          fi
        done
        
        # 7. Deploy HPA (needs deployments to exist first)
        echo "6. Deploying HPA..."
        if [ -d "k8s/base/hpa" ]; then
          kubectl apply -f k8s/base/hpa/ -n production-platform 2>/dev/null || echo "HPA may need metrics server"
        fi
        
        # 8. Deploy PDB (needs deployments to exist first)
        echo "7. Deploying PDB..."
        if [ -d "k8s/base/pdb" ]; then
          kubectl apply -f k8s/base/pdb/ -n production-platform
        fi
        
        # 9. Deploy Ingress (if exists)
        echo "8. Deploying Ingress..."
        if [ -d "k8s/base/ingress" ]; then
          kubectl apply -f k8s/base/ingress/ -n production-platform
        fi

        # ‚úÖ SECOND: Wait for Redis to be ready
        echo "‚è≥ Waiting for Redis to be ready..."
        sleep 20

        # 10. Update to newly built images
        echo "üîÑ Updating to new images..."
        kubectl set image deployment/api \
          api=${{ env.API_IMAGE }}:${{ github.sha }} \
          -n production-platform
        
        kubectl set image deployment/worker \
          worker=${{ env.WORKER_IMAGE }}:${{ github.sha }} \
          -n production-platform
        
        # 11. Wait for rollouts
        echo "‚è≥ Waiting for deployments..."
        kubectl rollout status deployment/api -n production-platform --timeout=120s
        kubectl rollout status deployment/worker -n production-platform --timeout=120s
        
        echo "‚úÖ All deployments complete!"
        
    - name: Test Deployment
      run: |
          echo "üß™ Testing deployment..."
        
          # Test API
           kubectl run test-curl --rm -i --restart=Never \
          --image=curlimages/curl:latest \
          --namespace=production-platform \
          -- curl -f http://api/health
        
           echo "‚úÖ API is healthy!"
        
          # Show deployment status
           echo ""
          echo "üìä Deployment Status:"
          kubectl get all -n production-platform
          
          echo ""
          echo "üìà HPA Status:"
          kubectl get hpa -n production-platform
        
          echo ""
          echo "üõ°Ô∏è PDB Status:"
          kubectl get pdb -n production-platform
    
    - name: Cleanup
      if: always()
      run: |
        # Delete Kind cluster
        kind delete cluster --name production-platform