name: Production Platform CI/CD

on:
  push:
    branches: [ main ]

env:
  REGISTRY: docker.io
  API_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-api
  WORKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/production-platform-worker

jobs:
  # ===== 1. Quality Gate =====
  quality:
    name: ğŸ§ª Quality Gate
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Run Tests
      run: |
        cd app/api-service && go test -v ./...
        cd ../worker-service && go test -v ./...
    
      

  # ===== 2. Build & Push =====
  build:
    name: ğŸ³ Build & Push
    runs-on: ubuntu-latest
    needs: quality
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build and push API
      uses: docker/build-push-action@v5
      with:
        context: ./app/api-service
        push: true
        tags: |
          ${{ env.API_IMAGE }}:${{ github.sha }}
          ${{ env.API_IMAGE }}:latest
    
    - name: Build and push Worker
      uses: docker/build-push-action@v5
      with:
        context: ./app/worker-service
        push: true
        tags: |
          ${{ env.WORKER_IMAGE }}:${{ github.sha }}
          ${{ env.WORKER_IMAGE }}:latest

  # ===== 3. Deploy to Kind (Kubernetes in Docker) =====
  deploy-test:
    name: ğŸš€ Deploy & Test
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Kind Cluster
      run: |
        # Install Kind (lightweight Kubernetes in Docker)
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin/kind
        
        # Create Kind configuration
        cat > kind-config.yaml <<EOF
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        nodes:
        - role: control-plane
          extraPortMappings:
          - containerPort: 30000
            hostPort: 30000
            protocol: TCP
        EOF
        
        # Create cluster
        kind create cluster --name production-platform --config kind-config.yaml
        
        # Verify
        kubectl cluster-info
        kubectl get nodes
    
    - name: Deploy to Kind
      run: |
        # Create namespace
        
        echo "ğŸ“¦ Deploying Kubernetes manifests in correct order..."
        
        # 1. First: Deploy namespace 
        if [ -f "k8s/base/namespace.yaml" ]; then
          echo "1. Applying namespace..."
          kubectl apply -f k8s/base/namespace.yaml
        fi
        
        # 2. Deploy ConfigMaps and Secrets
        echo "2. Applying configuration..."
        for config_file in k8s/base/configmap.yaml k8s/base/secret.yaml; do
          if [ -f "$config_file" ]; then
            kubectl apply -f "$config_file" -n production-platform
          fi
        done
        
        # 3. Deploy Redis first (StatefulSet, needs to be ready before API/Worker)
        echo "3. Deploying Redis (StatefulSet)..."
        if [ -d "k8s/base/redis" ]; then
          # Apply service before statefulset
          if [ -f "k8s/base/redis/service.yaml" ]; then
            kubectl apply -f k8s/base/redis/service.yaml -n production-platform
          fi
          if [ -f "k8s/base/redis/statefulset.yaml" ]; then
            kubectl apply -f k8s/base/redis/statefulset.yaml -n production-platform
          fi
        fi
        
        # 4. Wait for Redis to be ready
        echo "â³ Waiting for Redis to be ready..."
        sleep 20  # Give Redis time to start
        
        # 5. Deploy Services (before deployments that reference them)
        echo "4. Deploying Services..."
        for dir in api worker; do
          if [ -d "k8s/base/$dir" ] && [ -f "k8s/base/$dir/service.yaml" ]; then
            kubectl apply -f k8s/base/$dir/service.yaml -n production-platform
          fi
        done
        
        # 6. Deploy Deployments (API and Worker)
        echo "5. Deploying Deployments..."
        for dir in api worker; do
          if [ -d "k8s/base/$dir" ] && [ -f "k8s/base/$dir/deployment.yaml" ]; then
            kubectl apply -f k8s/base/$dir/deployment.yaml -n production-platform
          fi
        done
        
        # 7. Deploy HPA (needs deployments to exist first)
        echo "6. Deploying HPA..."
        if [ -d "k8s/base/hpa" ]; then
          kubectl apply -f k8s/base/hpa/ -n production-platform 2>/dev/null || echo "HPA may need metrics server"
        fi
        
        # 8. Deploy PDB (needs deployments to exist first)
        echo "7. Deploying PDB..."
        if [ -d "k8s/base/pdb" ]; then
          kubectl apply -f k8s/base/pdb/ -n production-platform
        fi
        
        # 9. Deploy Ingress (if exists)
        echo "8. Deploying Ingress..."
        if [ -d "k8s/base/ingress" ]; then
          kubectl apply -f k8s/base/ingress/ -n production-platform
        fi
        
        # 10. Update to newly built images
        echo "ğŸ”„ Updating to new images..."
        kubectl set image deployment/api \
          api=${{ env.API_IMAGE }}:${{ github.sha }} \
          -n production-platform
        
        kubectl set image deployment/worker \
          worker=${{ env.WORKER_IMAGE }}:${{ github.sha }} \
          -n production-platform
        
        # 11. Wait for rollouts
        echo "â³ Waiting for deployments..."
        kubectl rollout status deployment/api -n production-platform --timeout=120s
        kubectl rollout status deployment/worker -n production-platform --timeout=120s
        
        echo "âœ… All deployments complete!"
        
        - name: Test Deployment
          run: |
            echo "ğŸ§ª Testing deployment..."
        
        # Test API
        kubectl run test-curl --rm -i --restart=Never \
          --image=curlimages/curl:latest \
          --namespace=production-platform \
          -- curl -f http://api/health
        
        echo "âœ… API is healthy!"
        
        # Show deployment status
        echo ""
        echo "ğŸ“Š Deployment Status:"
        kubectl get all -n production-platform
        
        echo ""
        echo "ğŸ“ˆ HPA Status:"
        kubectl get hpa -n production-platform
        
        echo ""
        echo "ğŸ›¡ï¸ PDB Status:"
        kubectl get pdb -n production-platform
    
    - name: Cleanup
      if: always()
      run: |
        # Delete Kind cluster
        kind delete cluster --name production-platform